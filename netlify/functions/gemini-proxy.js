import { GoogleGenAI } from "@google/genai";

/**
 * Netlify serverless function to proxy requests to the Gemini API.
 * This secures the API key by keeping it server-side.
 * This file uses the modern ES Module syntax (import/export).
 */
export async function handler(event) {
    // 1. Security Check: Only allow POST requests
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            body: JSON.stringify({ message: "Method Not Allowed. Use POST." }),
        };
    }

    // 2. Access the API Key securely from the Netlify environment variables
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
        // Crucial for debugging Netlify server errors!
        console.error("SERVER ERROR: GEMINI_API_KEY environment variable is not set.");
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Server configuration error: GEMINI_API_KEY is missing. Check Netlify environment settings." }),
        };
    }
    
    // Initialize the Google GenAI client
    const ai = new GoogleGenAI({ apiKey });

    try {
        // 3. Parse the request body from the client (index.html)
        const { chatHistory, systemPrompt } = JSON.parse(event.body);

        if (!chatHistory || !systemPrompt) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Missing required fields (chatHistory or systemPrompt) in the request body." }),
            };
        }

        // 4. Construct the Gemini API payload with Search Grounding
        const generationConfig = {
            tools: [{ google_search: {} }], // Enable grounding
        };

        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-preview-09-2025",
            contents: chatHistory,
            config: generationConfig,
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            }
        });

        // 5. Extract results and grounding information
        const candidate = response.candidates?.[0];
        let text = candidate?.content?.parts?.[0]?.text || "No response generated by the model.";
        let sources = [];
        
        const groundingMetadata = candidate?.groundingMetadata;
        if (groundingMetadata && groundingMetadata.groundingAttributions) {
            sources = groundingMetadata.groundingAttributions
                .map(attribution => ({
                    uri: attribution.web?.uri,
                    title: attribution.web?.title,
                }));
        }

        // 6. Return the secure result to the client
        return {
            statusCode: 200,
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ 
                text: text, 
                sources: sources 
            }),
        };

    } catch (error) {
        // Log the detailed error on the server side
        console.error("Gemini API Function Error:", error.message, error.stack);

        // Try to extract a specific status code if the error object provides one
        const status = error.statusCode || 500;
        
        // Define a clearer detail message for the client
        let detailMessage = "An unknown error occurred on the Netlify server.";
        if (error.message) {
             detailMessage = error.message.includes('API key') 
                ? "API Key issue: Please check if your GEMINI_API_KEY is valid and correctly entered in Netlify."
                : error.message;
        }

        return {
            statusCode: status,
            body: JSON.stringify({ message: `Failed to communicate with the Gemini API. Status: ${status}. Details: ${detailMessage}` }),
        };
    }
}